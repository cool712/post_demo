<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
    <title>Pose Pro Optimized</title>
    <style>
        html, body { margin: 0; padding: 0; width: 100%; height: 100%; background: #000; overflow: hidden; }
        video, canvas { position: absolute; inset: 0; width: 100%; height: 100%; object-fit: cover; }
        .mirror { transform: scaleX(-1); }
        #tip { 
            position: absolute; top: 12px; left: 12px; z-index: 10; 
            color: #4ec9b0; background: rgba(0, 0, 0, 0.7); 
            padding: 6px 10px; border-radius: 4px; font-family: monospace; font-size: 12px;
            pointer-events: none;
        }
    </style>
</head>
<body>
    <div id="tip">System Initializing...</div>
    <video id="video" autoplay playsinline muted></video>
    <canvas id="canvas"></canvas>

    <script type="module">
        import { PoseLandmarker, FilesetResolver } from "/mediapipe/tasks-vision/vision_bundle.js";

        const video = document.getElementById("video");
        const canvas = document.getElementById("canvas");
        const ctx = canvas.getContext("2d");
        const tip = document.getElementById("tip");

        let poseLandmarker = null;
        let running = false;
        let facingMode = "user";
        let dynamicScale = 0.5;
        let frameCount = 0;
        let lastFpsCheck = 0;
        let isWarmUp = true; // 预热标记，防止启动时监控逻辑干扰

        /* ================= 摄像头逻辑 ================= */
        async function startCamera() {
            running = false;
            isWarmUp = true; 
            tip.textContent = "Camera adjusting...";

            if (video.srcObject) {
                const tracks = video.srcObject.getTracks();
                tracks.forEach(track => track.stop());
            }

            try {
                const stream = await navigator.mediaDevices.getUserMedia({
                    video: {
                        facingMode,
                        width: { ideal: 1280 },
                        height: { ideal: 720 }
                    }
                });

                video.srcObject = stream;
                await video.play();

                canvas.width = video.videoWidth;
                canvas.height = video.videoHeight;

                const mirror = facingMode === "user";
                video.className = mirror ? "mirror" : "";
                canvas.className = mirror ? "mirror" : "";

                running = true;
                tip.textContent = "System Ready";
                
                // 3秒后结束预热，开启性能动态调整
                setTimeout(() => { isWarmUp = false; }, 3000);
            } catch (err) {
                tip.textContent = "Camera Error";
            }
        }

        /* ================= AI 初始化 ================= */
        async function initAI() {
            try {
                const vision = await FilesetResolver.forVisionTasks("/mediapipe/tasks-vision/wasm");
                poseLandmarker = await PoseLandmarker.createFromOptions(vision, {
                    baseOptions: {
                        modelAssetPath: "/mediapipe/model/pose_landmarker_lite.task",
                        delegate: "GPU"
                    },
                    runningMode: "VIDEO",
                    numPoses: 1
                });
                requestAnimationFrame(loop);
            } catch (e) {
                tip.textContent = "AI Init Failed";
            }
        }

        /* ================= 主循环 (优化) ================= */
        function loop(ts) {
            requestAnimationFrame(loop);
            if (!running || !poseLandmarker) return;

            // 只有在预热结束后才进行复杂的 FPS 监控和动态调整
            if (!isWarmUp) {
                frameCount++;
                if (ts - lastFpsCheck > 1000) {
                    const fps = frameCount;
                    if (fps < 15 && dynamicScale > 0.3) dynamicScale -= 0.05;
                    else if (fps > 20 && dynamicScale < 1.0) dynamicScale += 0.05;
                    
                    tip.textContent = `FPS: ${fps} | Quality: ${Math.round(dynamicScale * 100)}%`;
                    frameCount = 0;
                    lastFpsCheck = ts;
                }
            }

            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            try {
                const result = poseLandmarker.detectForVideo(video, ts);
                if (result.landmarks && result.landmarks.length > 0) {
                    drawPose(result.landmarks[0]);
                }
            } catch (e) {}
        }

        function toCanvas(p) {
            return { x: p.x * canvas.width, y: p.y * canvas.height };
        }

        function drawPose(lm) {
            ctx.save();
            ctx.strokeStyle = "#00ff7f";
            ctx.lineWidth = 3;
            const bones = [[11,13],[13,15],[12,14],[14,16],[23,25],[25,27],[24,26],[26,28],[11,12],[23,24]];
            bones.forEach(([a, b]) => {
                const p1 = toCanvas(lm[a]), p2 = toCanvas(lm[b]);
                ctx.beginPath(); ctx.moveTo(p1.x, p1.y); ctx.lineTo(p2.x, p2.y); ctx.stroke();
            });
            ctx.restore();
        }

        /* ================= Flutter 接口 (修正) ================= */
        window.toggleCamera = async () => {
            facingMode = (facingMode === "user") ? "environment" : "user";
            await startCamera();
            return String(facingMode);
        };

        /* ================= 录制逻辑 ================= */
        let mediaRecorder;
        let recordedChunks = [];
        let startTime = 0;

        window.startRecord = function() {
            recordedChunks = [];
            startTime = Date.now();
            mediaRecorder = new MediaRecorder(video.srcObject);
            mediaRecorder.ondataavailable = e => recordedChunks.push(e.data);
            mediaRecorder.start();
        };

        window.stopAndUpload = async function(uploadUrl) {
            if (!mediaRecorder) return;
            mediaRecorder.onstop = async () => {
                const duration = (Date.now() - startTime) / 1000;
                const blob = new Blob(recordedChunks, { type: "video/webm" });
                const formData = new FormData();
                formData.append("file", blob, `rec_${Date.now()}.webm`);
                formData.append("duration", duration);
                try {
                    const res = await fetch(uploadUrl, { method: "POST", body: formData });
                    window.flutter_inappwebview.callHandler("onUploadComplete", { success: res.ok, duration });
                } catch (e) {
                    window.flutter_inappwebview.callHandler("onUploadComplete", { success: false });
                }
            };
            mediaRecorder.stop();
        };

        // 启动
        startCamera();
        initAI();
    </script>
</body>
</html>