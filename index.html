<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
        <title>Pose Pro Skeleton Recorder</title>
        <style>
            html, body { margin: 0; padding: 0; width: 100%; height: 100%; background: #000; overflow: hidden; }
            video, canvas { position: absolute; inset: 0; width: 100%; height: 100%; object-fit: cover; }
            #tip {
                position: absolute; top: 12px; left: 12px; z-index: 10;
                color: #4ec9b0; background: rgba(0, 0, 0, 0.7);
                padding: 6px 10px; border-radius: 4px; font-family: monospace; font-size: 11px;
            }
        </style>
    </head>

    <body>
        <div id="tip">Initializing...</div>
        <video id="video" autoplay playsinline muted style="display:none;"></video>
        <canvas id="canvas"></canvas>

        <script type="module">
            import { PoseLandmarker, FilesetResolver } from "/mediapipe/tasks-vision/vision_bundle.js";

            const video = document.getElementById("video");
            const canvas = document.getElementById("canvas");
            const ctx = canvas.getContext("2d", { alpha: false, desynchronized: true }); // 优化性能
            const tip = document.getElementById("tip");

            let poseLandmarker = null;
            let running = false;
            let facingMode = "user";
            let isRecording = false;
            let currentRecordFrameIndex = 0;
            let poseDataJson = {};
            let frameCount = 0;
            let lastFpsCheck = 0;

            async function startCamera() {
                if (video.srcObject) video.srcObject.getTracks().forEach(t => t.stop());
                try {
                    const stream = await navigator.mediaDevices.getUserMedia({
                        video: { facingMode, width: { ideal: 1280 }, height: { ideal: 720 } }
                    });
                    video.srcObject = stream;
                    return new Promise(resolve => {
                        video.onloadedmetadata = () => {
                            video.play();
                            canvas.width = video.videoWidth;
                            canvas.height = video.videoHeight;
                            running = true;
                            resolve();
                        };
                    });
                } catch (err) { tip.textContent = "Camera Error: " + err.message; }
            }

            async function initAI() {
                try {
                    const vision = await FilesetResolver.forVisionTasks("/mediapipe/tasks-vision/wasm");
                    poseLandmarker = await PoseLandmarker.createFromOptions(vision, {
                        baseOptions: { modelAssetPath: "/mediapipe/model/pose_landmarker_lite.task", delegate: "GPU" },
                        runningMode: "VIDEO", numPoses: 1
                    });
                    tip.textContent = "AI Ready";
                } catch (err) { tip.textContent = "AI Load Failed"; }
            }

            function loop(ts) {
                if (running && poseLandmarker) {
                    // 1. 绘制背景
                    ctx.save();
                    if (facingMode === "user") {
                        ctx.translate(canvas.width, 0);
                        ctx.scale(-1, 1);
                    }
                    ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
                    ctx.restore();

                    // 2. AI 检测
                    if (video.readyState >= 2) {
                        const result = poseLandmarker.detectForVideo(video, ts);
                        if (result.landmarks && result.landmarks.length > 0) {
                            drawPose(result.landmarks[0]);
                        }
                    }

                    // 3. FPS 显示
                    frameCount++;
                    if (ts - lastFpsCheck > 1000) {
                        tip.textContent = `FPS: ${frameCount} | Rec: ${isRecording ? 'ON' : 'OFF'}`;
                        frameCount = 0;
                        lastFpsCheck = ts;
                    }
                }
                requestAnimationFrame(loop);
            }

            function drawPose(lm) {
                if (isRecording) {
                    poseDataJson[`f_${currentRecordFrameIndex}`] = lm.map(p => [
                        Math.round(p.x * 1000) / 1000, 
                        Math.round(p.y * 1000) / 1000, 
                        Math.round(p.visibility * 100) / 100
                    ]);
                    currentRecordFrameIndex++;
                }

                ctx.save();
                ctx.strokeStyle = "#00ff7f";
                ctx.fillStyle = "#ffffff";
                ctx.lineWidth = 4;

                const bones = [[11,13],[13,15],[12,14],[14,16],[23,25],[25,27],[24,26],[26,28],[11,12],[23,24],[11,23],[12,24]];
                bones.forEach(([a, b]) => {
                    const pA = toCanvas(lm[a]);
                    const pB = toCanvas(lm[b]);
                    ctx.beginPath();
                    ctx.moveTo(pA.x, pA.y);
                    ctx.lineTo(pB.x, pB.y);
                    ctx.stroke();
                });
                ctx.restore();
            }

            function toCanvas(p) {
                let x = (facingMode === "user") ? (1 - p.x) : p.x;
                return { x: x * canvas.width, y: p.y * canvas.height };
            }

            /* ================= 录制逻辑：解决骨架消失 ================= */
            let mediaRecorder;
            let recordedChunks = [];

            window.startRecord = function() {
                recordedChunks = [];
                poseDataJson = {};
                currentRecordFrameIndex = 0;

                // 重点：如果 captureStream() 导致闪烁，尝试不带参数或降低帧率
                const stream = canvas.captureStream(25); 
                
                // 优先使用更通用的 webm 格式防止移动端编码器崩溃
                const options = { mimeType: 'video/webm;codecs=vp8' };
                mediaRecorder = new MediaRecorder(stream, options);

                mediaRecorder.ondataavailable = e => { if (e.data.size > 0) recordedChunks.push(e.data); };
                mediaRecorder.start();
                isRecording = true;
                console.log("Recording...");
            };

            window.stopAndUpload = async function(uploadUrl, token, flutterDuration) {
                isRecording = false;
                if (!mediaRecorder || mediaRecorder.state === "inactive") return;

                mediaRecorder.onstop = async () => {
                    const videoBlob = new Blob(recordedChunks, { type: "video/webm" });
                    const jsonBlob = new Blob([JSON.stringify(poseDataJson)], { type: "application/json" });

                    const formData = new FormData();
                    formData.append("file", videoBlob, "video.webm");
                    formData.append("pose_data", jsonBlob, "data.json");
                    formData.append("duration", flutterDuration);

                    try {
                        tip.textContent = "Uploading...";
                        // 注意：为了避免 OPTIONS 预检失败，测试阶段可以先注释掉 Authorization
                        const response = await fetch(uploadUrl, {
                            method: "POST",
                            // headers: { "Authorization": `Bearer ${token}` }, // 如果后端没配CORS，这行会触发OPTIONS并失败
                            body: formData
                        });

                        const res = await response.text();
                        window.flutter_inappwebview.callHandler("onUploadComplete", {
                            success: response.ok,
                            data: res
                        });
                        tip.textContent = "Done";
                    } catch (err) {
                        tip.textContent = "Upload Error";
                        console.error(err);
                    }
                };
                mediaRecorder.stop();
            };

            window.toggleCamera = async () => {
                running = false;
                facingMode = facingMode === "user" ? "environment" : "user";
                await startCamera();
                return facingMode;
            };

            async function main() {
                await startCamera();
                initAI();
                requestAnimationFrame(loop);
            }
            main();
        </script>
    </body>
</html>