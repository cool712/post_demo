<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
<title>Pose Detection</title>

<style>
html, body {
  margin: 0;
  padding: 0;
  width: 100%;
  height: 100%;
  background: black;
  overflow: hidden;
}
video, canvas {
  position: absolute;
  inset: 0;
  width: 100%;
  height: 100%;
  object-fit: cover;
}
canvas { pointer-events: none; }

#tip {
  position: absolute;
  top: 12px;
  left: 12px;
  color: #00ff66;
  font-size: 13px;
  font-family: monospace;
  z-index: 10;
  background: rgba(0,0,0,.4);
  padding: 6px 10px;
  border-radius: 6px;
}
</style>
</head>

<body>
<div id="tip">Initializing…</div>
<video id="video" autoplay playsinline muted></video>
<canvas id="canvas"></canvas>

<script type="module">
import {
  PoseLandmarker,
  FilesetResolver
} from "https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0";

const video = document.getElementById("video");
const canvas = document.getElementById("canvas");
const ctx = canvas.getContext("2d");
const tip = document.getElementById("tip");

let poseLandmarker = null;
let running = false;

/* ================= 工具 ================= */

function sleep(ms) {
  return new Promise(r => setTimeout(r, ms));
}

function withTimeout(promise, ms, label) {
  return Promise.race([
    promise,
    new Promise((_, reject) =>
      setTimeout(() => reject(new Error(label + " timeout")), ms)
    )
  ]);
}

function toCanvas(p) {
  return { x: p.x * canvas.width, y: p.y * canvas.height };
}

/* ================= 摄像头（最高优先级） ================= */

async function startCamera() {
  try {
    tip.textContent = "Starting camera…";

    const stream = await navigator.mediaDevices.getUserMedia({
      video: {
        facingMode: "environment",
        width: { ideal: 720 },
        height: { ideal: 540 }
      },
      audio: false
    });

    video.srcObject = stream;
    await new Promise(r => video.onloadedmetadata = r);
    await video.play();

    canvas.width = video.videoWidth;
    canvas.height = video.videoHeight;

    running = true;
    tip.textContent = "Camera ready";

  } catch (e) {
    tip.textContent = "Camera failed";
    console.error(e);
  }
}

/* ================= Pose 初始化（最容易挂） ================= */

async function initPose() {
  try {
    tip.textContent = "Loading AI…";

    const vision = await withTimeout(
      FilesetResolver.forVisionTasks(
        "/mediapipe/wasm",
        {
          wasmLoaderPath: "/mediapipe/wasm/vision_wasm_nosimd.js"
        }
      ),
      5000,
      "WASM"
    );

    poseLandmarker = await withTimeout(
      PoseLandmarker.createFromOptions(vision, {
        baseOptions: {
          modelAssetPath: "/mediapipe/model/pose_landmarker_lite.task",
          delegate: "CPU"
        },
        runningMode: "VIDEO",
        numPoses: 1
      }),
      8000,
      "POSE"
    );

    tip.textContent = "Pose ready";

  } catch (e) {
    console.warn("Pose disabled:", e);
    tip.textContent = "AI not supported on this device";
    poseLandmarker = null;
  }
}

/* ================= 主循环（永不阻塞） ================= */

let lastAI = 0;
const AI_INTERVAL = 1000 / 15;

function loop(ts) {
  requestAnimationFrame(loop);

  if (!running || !poseLandmarker) return;
  if (ts - lastAI < AI_INTERVAL) return;
  lastAI = ts;

  ctx.clearRect(0, 0, canvas.width, canvas.height);

  const result = poseLandmarker.detectForVideo(video, ts);
  if (!result.landmarks.length) return;

  drawPose(result.landmarks[0]);
}

/* ================= 绘制 ================= */

function drawPose(lm) {
  ctx.strokeStyle = "#00ff66";
  ctx.fillStyle = "#00ff66";
  ctx.lineWidth = 3;

  const bones = [
    [11,13],[13,15],[12,14],[14,16],
    [23,25],[25,27],[24,26],[26,28],
    [11,12],[23,24],[11,23],[12,24]
  ];

  bones.forEach(([a,b]) => {
    const A = toCanvas(lm[a]);
    const B = toCanvas(lm[b]);
    ctx.beginPath();
    ctx.moveTo(A.x, A.y);
    ctx.lineTo(B.x, B.y);
    ctx.stroke();
  });

  lm.forEach(p => {
    const c = toCanvas(p);
    ctx.beginPath();
    ctx.arc(c.x, c.y, 4, 0, Math.PI * 2);
    ctx.fill();
  });
}

/* ================= 启动 ================= */

startCamera();   // 立刻
initPose();      // 后台
requestAnimationFrame(loop);
</script>
</body>
</html>
