<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="UTF-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
		<title>Pose Pro Optimized</title>

		<style>
			html, body {
				margin: 0; padding: 0;
				width: 100%; height: 100%;
				background: #000;
				overflow: hidden;
			}

			video, canvas {
				position: absolute;
				inset: 0;
				width: 100%;
				height: 100%;
				object-fit: cover;
				background: #1a1a1a; /* 增加底色，避免纯黑 */
			}

			.mirror { transform: scaleX(-1); -webkit-transform: scaleX(-1); }

			#tip {
				position: absolute;
				top: 12px; left: 12px;
				z-index: 20;
				color: #4ec9b0;
				background: rgba(0, 0, 0, 0.7);
				padding: 6px 10px;
				border-radius: 4px;
				font-family: monospace;
				font-size: 12px;
			}

			/* --- 新增：加载动画遮罩 --- */
			#loading-overlay {
				position: absolute;
				inset: 0;
				z-index: 15;
				background: #000;
				display: flex;
				flex-direction: column;
				align-items: center;
				justify-content: center;
				transition: opacity 0.5s ease;
			}

			.spinner {
				width: 40px;
				height: 40px;
				border: 3px solid rgba(78, 201, 176, 0.3);
				border-top: 3px solid #4ec9b0;
				border-radius: 50%;
				animation: spin 1s linear infinite;
				margin-bottom: 15px;
			}

			@keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

			.hidden { opacity: 0; pointer-events: none; }
		</style>
	</head>

	<body>
		<div id="loading-overlay">
			<div class="spinner"></div>
			<div style="color: #4ec9b0; font-family: monospace; font-size: 14px;">Loading AI & Camera...</div>
		</div>

		<div id="tip">Initializing...</div>
		<video id="video" autoplay playsinline muted></video>
		<canvas id="canvas"></canvas>

		<script type="module">
			import { PoseLandmarker, FilesetResolver } from "/mediapipe/tasks-vision/vision_bundle.js";

			const video = document.getElementById("video");
			const canvas = document.getElementById("canvas");
			const ctx = canvas.getContext("2d");
			const tip = document.getElementById("tip");
			const overlay = document.getElementById("loading-overlay");

			let poseLandmarker = null;
			let running = false;
			let facingMode = "environment"; 

			/* ================= 1. 摄像头启动优化 ================= */
			async function startCamera() {
				if (video.srcObject) {
					video.srcObject.getTracks().forEach(t => t.stop());
				}

				try {
					const stream = await navigator.mediaDevices.getUserMedia({
						video: {
							facingMode: facingMode,
							width: { ideal: 640 }, // 初始请求低分辨率，建立连接更快
							height: { ideal: 480 }
						}
					});

					video.srcObject = stream;

					// 等待元数据加载，但不阻塞主逻辑
					return new Promise((resolve) => {
						video.onloadedmetadata = () => {
							canvas.width = video.videoWidth;
							canvas.height = video.videoHeight;
							
							const isMirror = facingMode === "user";
							video.classList.toggle("mirror", isMirror);
							canvas.classList.toggle("mirror", isMirror);
							
							video.play();
							running = true;
							resolve();
						};
					});
				} catch (err) {
					tip.textContent = "Camera Error";
					throw err;
				}
			}

			/* ================= 2. AI 初始化优化 ================= */
			async function initAI() {
				try {
					const vision = await FilesetResolver.forVisionTasks("/mediapipe/tasks-vision/wasm");
					poseLandmarker = await PoseLandmarker.createFromOptions(vision, {
						baseOptions: {
							modelAssetPath: "/mediapipe/model/pose_landmarker_lite.task",
							delegate: "GPU"
						},
						runningMode: "VIDEO",
						numPoses: 1
					});
				} catch (err) {
					tip.textContent = "AI Init Error";
					throw err;
				}
			}

			/* ================= 3. 渲染主循环 ================= */
			function loop(ts) {
				if (running && poseLandmarker) {
					// 只有在数据准备好后才隐藏遮罩
					if (!overlay.classList.contains("hidden")) {
						overlay.classList.add("hidden");
						tip.textContent = "Ready";
					}

					ctx.clearRect(0, 0, canvas.width, canvas.height);
					const result = poseLandmarker.detectForVideo(video, ts);
					if (result.landmarks && result.landmarks[0]) {
						drawPose(result.landmarks[0]);
					}
				}
				requestAnimationFrame(loop);
			}

			/* ================= 绘制逻辑 ================= */
			function drawPose(lm) {
				ctx.save();
				ctx.strokeStyle = "#00ff7f";
				ctx.lineWidth = 3;
				const toC = (p) => ({ x: p.x * canvas.width, y: p.y * canvas.height });
				const bones = [[11,13],[13,15],[12,14],[14,16],[23,25],[25,27],[24,26],[26,28],[11,12],[23,24],[11,23],[12,24]];
				
				bones.forEach(([a, b]) => {
					const pA = toC(lm[a]), pB = toC(lm[b]);
					ctx.beginPath(); ctx.moveTo(pA.x, pA.y); ctx.lineTo(pB.x, pB.y); ctx.stroke();
				});
				ctx.restore();
			}

			/* ================= 4. 启动控制 (核心优化) ================= */
			(async function bootstrap() {
				// 并行启动，不互相等待
				try {
					await Promise.all([startCamera(), initAI()]);
					requestAnimationFrame(loop);
				} catch (e) {
					console.error("Bootstrap error:", e);
					tip.textContent = "Error: Check permissions";
				}
			})();

			/* 切换摄像头 */
			window.toggleCamera = async () => {
				overlay.classList.remove("hidden"); // 切换时再次显示遮罩
				facingMode = (facingMode === "user") ? "environment" : "user";
				await startCamera();
				// 切换后遮罩会在 loop 第一帧自动隐藏
			};
		</script>
	</body>
</html>