<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="UTF-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
		<title>Pose Pro Optimized</title>
		<style>
			html, body {
				margin: 0; padding: 0;
				width: 100%; height: 100%;
				background: #000;
				overflow: hidden;
			}
			video, canvas {
				position: absolute;
				inset: 0;
				width: 100%;
				height: 100%;
				object-fit: cover;
			}
			/* 仅当前置时翻转 */
			.mirror {
				transform: scaleX(-1);
				-webkit-transform: scaleX(-1);
			}
			#tip {
				position: absolute;
				top: env(safe-area-inset-top, 12px);
				left: 12px;
				z-index: 10;
				color: #4ec9b0;
				background: rgba(0, 0, 0, 0.7);
				padding: 6px 12px;
				border-radius: 4px;
				font-family: monospace;
				font-size: 12px;
				pointer-events: none;
			}
		</style>
	</head>
	<body>
		<div id="tip">System Loading...</div>
		<video id="video" autoplay playsinline muted></video>
		<canvas id="canvas"></canvas>

		<script type="module">
			import { PoseLandmarker, FilesetResolver } from "/mediapipe/tasks-vision/vision_bundle.js";

			const video = document.getElementById("video");
			const canvas = document.getElementById("canvas");
			const ctx = canvas.getContext("2d");
			const tip = document.getElementById("tip");

			let poseLandmarker = null;
			let running = false;
			let facingMode = "environment"; // 默认后置摄像头
			let dynamicScale = 0.5;
			let frameCount = 0;
			let lastFpsCheck = 0;
			let startTime = 0;

			/* ================= 1. 快速启动摄像头 ================= */
			async function startCamera() {
				if (video.srcObject) {
					video.srcObject.getTracks().forEach(t => t.stop());
				}

				try {
					// 优化：使用简单的约束条件加快协商速度
					const stream = await navigator.mediaDevices.getUserMedia({
						video: {
							facingMode: facingMode,
							width: { ideal: 640 }, // 初始请求较低分辨率，提高成功率
							height: { ideal: 480 }
						},
						audio: false
					});

					video.srcObject = stream;
					
					// 使用 promise 等待视频元数据加载
					return new Promise((resolve) => {
						video.onloadedmetadata = () => {
							canvas.width = video.videoWidth;
							canvas.height = video.videoHeight;
							
							const isMirror = facingMode === "user";
							video.classList.toggle("mirror", isMirror);
							canvas.classList.toggle("mirror", isMirror);
							
							video.play();
							running = true;
							console.log("Camera Stream Started");
							resolve();
						};
					});
				} catch (err) {
					tip.textContent = "Camera Error: " + err.message;
					throw err;
				}
			}

			/* ================= 2. 异步加载 AI ================= */
			async function initAI() {
				try {
					const vision = await FilesetResolver.forVisionTasks("/mediapipe/tasks-vision/wasm");
					poseLandmarker = await PoseLandmarker.createFromOptions(vision, {
						baseOptions: {
							modelAssetPath: "/mediapipe/model/pose_landmarker_lite.task",
							delegate: "GPU"
						},
						runningMode: "VIDEO",
						numPoses: 1
					});
					console.log("AI Model Loaded");
				} catch (err) {
					tip.textContent = "AI Model Error";
					throw err;
				}
			}

			/* ================= 3. 渲染循环 ================= */
			function loop(ts) {
				if (running && poseLandmarker) {
					// 性能监控
					frameCount++;
					if (ts - lastFpsCheck > 1000) {
						const fps = frameCount;
						if (fps < 12 && dynamicScale > 0.3) dynamicScale -= 0.1;
						else if (fps > 14 && dynamicScale < 1.0) dynamicScale += 0.1;
						tip.textContent = `FPS: ${fps} | Cam: ${facingMode}`;
						frameCount = 0;
						lastFpsCheck = ts;
					}

					ctx.clearRect(0, 0, canvas.width, canvas.height);
					
					// 识别
					const result = poseLandmarker.detectForVideo(video, ts);
					if (result.landmarks && result.landmarks[0]) {
						drawPose(result.landmarks[0]);
					}
				}
				requestAnimationFrame(loop);
			}

			/* ================= 绘制逻辑 ================= */
			function drawPose(lm) {
				ctx.save();
				ctx.strokeStyle = "#00ff7f";
				ctx.fillStyle = "#ffffff";
				ctx.lineWidth = 3;
				ctx.lineCap = "round";

				const bones = [
					[11, 13], [13, 15], [12, 14], [14, 16], [23, 25], 
					[25, 27], [24, 26], [26, 28], [11, 12], [23, 24], 
					[11, 23], [12, 24]
				];

				const toC = (p) => ({ x: p.x * canvas.width, y: p.y * canvas.height });

				bones.forEach(([a, b]) => {
					const pA = toC(lm[a]), pB = toC(lm[b]);
					ctx.beginPath();
					ctx.moveTo(pA.x, pA.y);
					ctx.lineTo(pB.x, pB.y);
					ctx.stroke();
				});

				lm.forEach(p => {
					const cp = toC(p);
					ctx.beginPath();
					ctx.arc(cp.x, cp.y, 3, 0, Math.PI * 2);
					ctx.fill();
				});

				// 绘制角度示例 (左肘)
				const getAngle = (a, b, c) => {
					const d1 = { x: a.x - b.x, y: a.y - b.y };
					const d2 = { x: c.x - b.x, y: c.y - b.y };
					const angle = Math.acos((d1.x*d2.x + d1.y*d2.y) / (Math.hypot(d1.x, d1.y) * Math.hypot(d2.x, d2.y)));
					return Math.round(angle * 180 / Math.PI);
				};
				
				const joints = [[11,13,15], [12,14,16], [23,25,27], [24,26,28]];
				ctx.font = "14px monospace";
				joints.forEach(([a,b,c]) => {
					const ang = getAngle(lm[a], lm[b], lm[c]);
					const pos = toC(lm[b]);
					ctx.fillText(`${ang}°`, pos.x + 8, pos.y - 8);
				});
				ctx.restore();
			}

			/* ================= 接口：供 Flutter 调用 ================= */
			window.toggleCamera = async () => {
				facingMode = (facingMode === "user") ? "environment" : "user";
				await startCamera();
				return facingMode;
			};

			let mediaRecorder;
			let recordedChunks = [];
			window.startRecord = function() {
				startTime = Date.now();
				recordedChunks = [];
				mediaRecorder = new MediaRecorder(video.srcObject);
				mediaRecorder.ondataavailable = e => e.data.size > 0 && recordedChunks.push(e.data);
				mediaRecorder.start();
				tip.textContent = "Recording...";
			};

			window.stopAndUpload = async function(uploadUrl) {
				if (!mediaRecorder || mediaRecorder.state === "inactive") return;
				mediaRecorder.onstop = async () => {
					const duration = (Date.now() - startTime) / 1000;
					const blob = new Blob(recordedChunks, { type: mediaRecorder.mimeType });
					const formData = new FormData();
					formData.append("file", blob, `rec_${Date.now()}.webm`);
					formData.append("duration", duration);

					try {
						const res = await fetch(uploadUrl, { method: "POST", body: formData });
						window.flutter_inappwebview.callHandler("onUploadComplete", {
							success: res.ok,
							status: res.status
						});
						tip.textContent = res.ok ? "Upload Success" : "Upload Failed";
					} catch (e) {
						tip.textContent = "Upload Error";
					}
				};
				mediaRecorder.stop();
			};

			/* ================= 启动逻辑：并行执行 ================= */
			(async function init() {
				try {
					// 同时开始摄像头和AI初始化
					await Promise.all([startCamera(), initAI()]);
					tip.textContent = "Ready";
					requestAnimationFrame(loop);
				} catch (e) {
					tip.textContent = "Init Failed";
				}
			})();
		</script>
	</body>
</html>