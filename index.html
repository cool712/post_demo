<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>MediaPipe Pose Landmarker Demo</title>

  <!-- Material UI（可选） -->
  <link href="https://unpkg.com/material-components-web@latest/dist/material-components-web.min.css" rel="stylesheet">
  <script src="https://unpkg.com/material-components-web@latest/dist/material-components-web.min.js"></script>

  <!-- ===== CSS（由 SCSS 转换而来）===== -->
  <style>
    body {
      font-family: Roboto, Arial, sans-serif;
      margin: 2em;
      color: #3d3d3d;
      --mdc-theme-primary: #007f8b;
      --mdc-theme-on-primary: #f1f3f4;
    }

    h1 { color: #007f8b; }
    h2 { clear: both; }
    em { font-weight: bold; }

    video {
      clear: both;
      display: block;
      transform: rotateY(180deg);
    }

    section {
      opacity: 1;
      transition: opacity 500ms ease-in-out;
    }

    .removed { display: none; }
    .invisible { opacity: 0.2; }

    .videoView,
    .detectOnClick {
      position: relative;
      float: left;
      width: 48%;
      margin: 2% 1%;
      cursor: pointer;
    }

    .canvas,
    .output_canvas {
      position: absolute;
      left: 0;
      top: 0;
      pointer-events: none;
      transform: rotateY(180deg);
    }

    .detectOnClick img {
      width: 100%;
    }
  </style>
</head>

<body>
  <h1>Pose detection using MediaPipe PoseLandmarker</h1>

  <section id="demos" class="invisible">
    <h2>Demo: Detecting Images</h2>

    <div class="detectOnClick">
      <img src="https://assets.codepen.io/9177687/woman-ge0f199f92_640.jpg" crossorigin="anonymous">
    </div>

    <div class="detectOnClick">
      <img src="https://assets.codepen.io/9177687/woman-g1af8d3deb_640.jpg" crossorigin="anonymous">
    </div>

    <h2>Demo: Webcam continuous pose detection</h2>

    <div class="videoView">
      <button id="webcamButton" class="mdc-button mdc-button--raised">
        <span class="mdc-button__label">ENABLE WEBCAM</span>
      </button>

      <div style="position: relative;">
        <video id="webcam" autoplay playsinline width="480" height="360"></video>
        <canvas id="output_canvas" width="480" height="360" class="output_canvas"></canvas>
      </div>
    </div>
  </section>

  <!-- ===== JS（去掉 TS 类型，浏览器可直接运行）===== -->
  <script type="module">
    import {
      PoseLandmarker,
      FilesetResolver,
      DrawingUtils
    } from "https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0";

    const demosSection = document.getElementById("demos");

    let poseLandmarker;
    let runningMode = "IMAGE";
    let webcamRunning = false;
    const videoHeight = "360px";
    const videoWidth = "480px";

    async function createPoseLandmarker() {
      const vision = await FilesetResolver.forVisionTasks(
        "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm"
      );

      poseLandmarker = await PoseLandmarker.createFromOptions(vision, {
        baseOptions: {
          modelAssetPath:
            "https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task",
          delegate: "GPU"
        },
        runningMode,
        numPoses: 2
      });

      demosSection.classList.remove("invisible");
    }

    createPoseLandmarker();

    /* ---------- Image detection ---------- */
    const imageContainers = document.getElementsByClassName("detectOnClick");

    for (let i = 0; i < imageContainers.length; i++) {
      imageContainers[i].children[0].addEventListener("click", handleClick);
    }

    async function handleClick(event) {
      if (!poseLandmarker) return;

      if (runningMode === "VIDEO") {
        runningMode = "IMAGE";
        await poseLandmarker.setOptions({ runningMode: "IMAGE" });
      }

      poseLandmarker.detect(event.target, (result) => {
        const canvas = document.createElement("canvas");
        canvas.className = "canvas";
        canvas.width = event.target.naturalWidth;
        canvas.height = event.target.naturalHeight;
        canvas.style.width = event.target.width + "px";
        canvas.style.height = event.target.height + "px";

        event.target.parentNode.appendChild(canvas);
        const ctx = canvas.getContext("2d");
        const drawingUtils = new DrawingUtils(ctx);

        for (const landmark of result.landmarks) {
          drawingUtils.drawLandmarks(landmark);
          drawingUtils.drawConnectors(
            landmark,
            PoseLandmarker.POSE_CONNECTIONS
          );
        }
      });
    }

    /* ---------- Webcam detection ---------- */
    const video = document.getElementById("webcam");
    const canvasElement = document.getElementById("output_canvas");
    const canvasCtx = canvasElement.getContext("2d");
    const drawingUtils = new DrawingUtils(canvasCtx);
    const webcamButton = document.getElementById("webcamButton");

    webcamButton.onclick = async () => {
      webcamRunning = !webcamRunning;
      webcamButton.innerText = webcamRunning
        ? "DISABLE WEBCAM"
        : "ENABLE WEBCAM";

      if (!webcamRunning) return;

      const stream = await navigator.mediaDevices.getUserMedia({ video: true });
      video.srcObject = stream;
      video.onloadeddata = predictWebcam;
    };

    let lastVideoTime = -1;
    async function predictWebcam() {
      if (runningMode === "IMAGE") {
        runningMode = "VIDEO";
        await poseLandmarker.setOptions({ runningMode: "VIDEO" });
      }

      if (video.currentTime !== lastVideoTime) {
        lastVideoTime = video.currentTime;

        poseLandmarker.detectForVideo(video, performance.now(), (result) => {
          canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);
          for (const landmark of result.landmarks) {
            drawingUtils.drawLandmarks(landmark);
            drawingUtils.drawConnectors(
              landmark,
              PoseLandmarker.POSE_CONNECTIONS
            );
          }
        });
      }

      if (webcamRunning) {
        requestAnimationFrame(predictWebcam);
      }
    }
  </script>
</body>
</html>
