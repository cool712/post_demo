<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="UTF-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
		<title>Pose Pro Fixed</title>

		<style>
			html,
			body {
				margin: 0;
				padding: 0;
				width: 100%;
				height: 100%;
				background: #000;
				overflow: hidden;
				font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
			}

			/* 基础视频与画布：默认透明，加载后淡入 */
			video,
			canvas {
				position: absolute;
				inset: 0;
				width: 100%;
				height: 100%;
				object-fit: cover;
				opacity: 0;
				transition: opacity 1s ease;
			}

			/* 当准备就绪时添加此类 */
			.ready {
				opacity: 1 !important;
			}

			.mirror {
				transform: scaleX(-1);
				-webkit-transform: scaleX(-1);
			}

			/* 状态提示栏 */
			#tip {
				position: absolute;
				top: 12px;
				left: 12px;
				z-index: 10;
				color: #4ec9b0;
				background: rgba(0, 0, 0, 0.7);
				backdrop-filter: blur(4px);
				padding: 6px 12px;
				border-radius: 6px;
				font-family: monospace;
				font-size: 12px;
				border-left: 3px solid #4ec9b0;
				box-shadow: 0 4px 12px rgba(0,0,0,0.5);
			}

			/* 启动页动画 */
			#loader-overlay {
				position: absolute;
				inset: 0;
				background: #000;
				display: flex;
				flex-direction: column;
				justify-content: center;
				align-items: center;
				z-index: 100;
				transition: opacity 0.6s ease;
			}

			.spinner {
				width: 48px;
				height: 48px;
				border: 3px solid rgba(78, 201, 176, 0.1);
				border-top: 3px solid #4ec9b0;
				border-radius: 50%;
				animation: spin 1s cubic-bezier(0.4, 0, 0.2, 1) infinite;
				margin-bottom: 20px;
			}

			@keyframes spin {
				to { transform: rotate(360deg); }
			}

			.loading-text {
				color: #4ec9b0;
				letter-spacing: 2px;
				font-size: 14px;
				animation: breathe 2s ease-in-out infinite;
			}

			@keyframes breathe {
				0%, 100% { opacity: 0.5; }
				50% { opacity: 1; }
			}
		</style>
	</head>

	<body>
		<div id="loader-overlay">
			<div class="spinner"></div>
			<div class="loading-text">SYSTEM INITIALIZING</div>
		</div>

		<div id="tip">Initializing...</div>
		<video id="video" autoplay playsinline muted></video>
		<canvas id="canvas"></canvas>

		<script type="module">
			import {
				PoseLandmarker,
				FilesetResolver
			}
			from "/mediapipe/tasks-vision/vision_bundle.js";

			/* ---------- DOM ---------- */
			const video = document.getElementById("video");
			const canvas = document.getElementById("canvas");
			const ctx = canvas.getContext("2d");
			const tip = document.getElementById("tip");
			const loader = document.getElementById("loader-overlay");

			/* ---------- 状态 ---------- */
			let poseLandmarker = null;
			let running = false;
			let facingMode = "user";
			let dynamicScale = 0.5; 
			let frameCount = 0;
			let lastFpsCheck = 0;

			/* ================= 摄像头控制 ================= */
			async function startCamera() {
				running = false;
				tip.textContent = "Camera activating...";
				
				// 切换时轻微淡出
				video.classList.remove("ready");
				canvas.classList.remove("ready");

				if (video.srcObject) {
					video.srcObject.getTracks().forEach(t => t.stop());
				}

				try {
					const stream = await navigator.mediaDevices.getUserMedia({
						video: {
							facingMode,
							width: { ideal: 1280 },
							height: { ideal: 720 }
						}
					});

					video.srcObject = stream;
					
					// 等待元数据加载以获取正确尺寸
					await new Promise(resolve => video.onloadedmetadata = resolve);
					await video.play();

					canvas.width = video.videoWidth;
					canvas.height = video.videoHeight;

					const mirror = facingMode === "user";
					video.className = mirror ? "mirror ready" : "ready";
					canvas.className = mirror ? "mirror ready" : "ready";

					running = true;
					tip.textContent = `Camera OK (${facingMode})`;
				} catch (err) {
					tip.textContent = "Camera Error: " + err.message;
				}
			}

			/* ================= AI 初始化 ================= */
			async function initAI() {
				try {
					tip.textContent = "AI Model Loading...";
					const vision = await FilesetResolver.forVisionTasks(
						"/mediapipe/tasks-vision/wasm"
					);

					poseLandmarker = await PoseLandmarker.createFromOptions(vision, {
						baseOptions: {
							modelAssetPath: "/mediapipe/model/pose_landmarker_lite.task",
							delegate: "GPU"
						},
						runningMode: "VIDEO",
						numPoses: 1
					});

					tip.textContent = "AI Ready";
					
					// AI 加载完成后，移除启动遮罩
					if(loader) {
						loader.style.opacity = "0";
						setTimeout(() => loader.remove(), 600);
					}

					requestAnimationFrame(loop);
				} catch (err) {
					tip.textContent = "AI Init Error";
					console.error(err);
				}
			}

			/* ================= 主循环 ================= */
			function loop(ts) {
				requestAnimationFrame(loop);
				if (!running || !poseLandmarker) return;

				// 性能监控
				frameCount++;
				if (ts - lastFpsCheck > 1000) {
					const fps = frameCount;
					if (fps < 12 && dynamicScale > 0.3) dynamicScale -= 0.1;
					else if (fps > 14 && dynamicScale < 1.0) dynamicScale += 0.1;
					
					tip.textContent = `Quality: ${Math.round(dynamicScale * 100)}% | FPS: ${fps}`;
					frameCount = 0;
					lastFpsCheck = ts;
				}

				ctx.clearRect(0, 0, canvas.width, canvas.height);
				
				// 推理
				const result = poseLandmarker.detectForVideo(video, ts);
				if (result.landmarks && result.landmarks.length > 0) {
					drawPose(result.landmarks[0]);
				}
			}

			/* ================= 绘制逻辑 ================= */
			function drawPose(lm) {
				ctx.save();
				ctx.strokeStyle = "#00ff7f";
				ctx.fillStyle = "#ffffff";
				ctx.lineWidth = 4;
				ctx.lineCap = "round";
				ctx.lineJoin = "round";

				const bones = [
					[11, 13], [13, 15], [12, 14], [14, 16],
					[23, 25], [25, 27], [24, 26], [26, 28],
					[11, 12], [23, 24], [11, 23], [12, 24]
				];

				bones.forEach(([a, b]) => drawLine(toCanvas(lm[a]), toCanvas(lm[b])));
				lm.forEach(p => drawPoint(toCanvas(p)));

				// 绘制关键角度
				drawAngle(lm[11], lm[13], lm[15]); // 左肘
				drawAngle(lm[12], lm[14], lm[16]); // 右肘
				drawAngle(lm[23], lm[25], lm[27]); // 左膝
				drawAngle(lm[24], lm[26], lm[28]); // 右膝

				ctx.restore();
			}

			function toCanvas(p) {
				return { x: p.x * canvas.width, y: p.y * canvas.height };
			}

			function drawLine(a, b) {
				if (!a || !b) return;
				ctx.beginPath();
				ctx.moveTo(a.x, a.y);
				ctx.lineTo(b.x, b.y);
				ctx.stroke();
			}

			function drawPoint(p) {
				ctx.beginPath();
				ctx.arc(p.x, p.y, 4, 0, Math.PI * 2);
				ctx.fill();
			}

			function calcAngle(a, b, c) {
				const ab = { x: a.x - b.x, y: a.y - b.y };
				const cb = { x: c.x - b.x, y: c.y - b.y };
				const dot = ab.x * cb.x + ab.y * cb.y;
				const mag1 = Math.hypot(ab.x, ab.y);
				const mag2 = Math.hypot(cb.x, cb.y);
				return Math.acos(dot / (mag1 * mag2)) * 180 / Math.PI;
			}

			function drawAngle(a, b, c) {
				const angle = Math.round(calcAngle(a, b, c));
				const p = toCanvas(b);
				ctx.fillStyle = "#4ec9b0";
				ctx.font = "bold 14px monospace";
				ctx.fillText(`${angle}°`, p.x + 8, p.y - 8);
			}

			/* ================= 录制与 Flutter 接口 ================= */
			let mediaRecorder;
			let recordedChunks = [];
			let startTime;

			window.startRecord = function() {
				recordedChunks = [];
				startTime = Date.now();
				mediaRecorder = new MediaRecorder(video.srcObject);
				mediaRecorder.ondataavailable = e => recordedChunks.push(e.data);
				mediaRecorder.start();
				tip.style.borderLeftColor = "#ff4757"; // 录制时提示框变红
			};

			window.stopAndUpload = async function(uploadUrl, token) {
				if (!mediaRecorder || mediaRecorder.state === "inactive") return;

				mediaRecorder.onstop = async () => {
					const duration = (Date.now() - startTime) / 1000;
					const blob = new Blob(recordedChunks, { type: mediaRecorder.mimeType });
					const formData = new FormData();
					const ext = mediaRecorder.mimeType.includes("mp4") ? "mp4" : "webm";
					
					formData.append("file", blob, `record_${Date.now()}.${ext}`);
					formData.append("duration", duration);

					try {
						tip.textContent = "Uploading...";
						const response = await fetch(uploadUrl, {
							method: "POST",
							body: formData
						});

						window.flutter_inappwebview.callHandler("onUploadComplete", {
							success: response.ok,
							status: response.status,
							duration: duration
						});
						tip.textContent = response.ok ? "Upload Success" : "Upload Failed";
						tip.style.borderLeftColor = "#4ec9b0";
					} catch (err) {
						window.flutter_inappwebview.callHandler("onUploadComplete", {
							success: false,
							error: err.message
						});
					}
				};
				mediaRecorder.stop();
			};

			window.toggleCamera = async () => {
				facingMode = facingMode === "user" ? "environment" : "user";
				await startCamera();
				return facingMode;
			};

			/* ================= 启动 ================= */
			startCamera();
			initAI();
			
		</script>
	</body>
</html>s